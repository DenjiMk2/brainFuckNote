# 文字列反転 メモ書き
## コード
```
+[,[>+>+<<-]>>[<<+>>-]<----------]<[<.]
```
## 動作
起動すると、文字列の入力を受け付ける。
文字列を入力して最後に終端文字として改行で入力文字列を入力すると、それを反転した文字列を出力する。（正確にはASCIIで10以下の文字が終端）
## 動作メモ
```
+
```
繰り返しにはいるために必要だった。
直後に`,`でメモリの値がつぶされるので影響なし。

### 入力受け取り部
```
[,[>+>+<<-]>>[<<+>>-]<----------]
```
プログラムの前半部分、この部分だけで改行(ASCIIで10以下)を受け取るまでメモリに入力文字列を並べるプログラム
#### 例
##### 入力
abcdef[LF]
##### 出力
fedcba
#### 解説
まず、入力`abcdef[LF]`を想定して、入力部全体で目指すメモリの状態は以下の状態
```
 0:97(a)
 1:98(b)
 2:99(c)
.........
 5:102(f)
```
このメモリ状態を目指す。
```
[,
```
繰り返しの中で最初の番地に入力文字列を受け取る。
なお、各ループではポインタの番地以前は触らないように気を付ける。(番地1を差している場合は、前ループで0番地にaの入力が入っているはずなので、触らないように)  
aが入力されたとしてメモリの状態
```
>0:97(a)
```
\>は現在の番地を示す。  

ここから、受け取った値を現在の番地以降を使用してコピーして繰り返しに使用する（繰り返しはカウンタの値を変更してしまうため）  
この中で、入力文字列に対して行いたい処理は「その文字が10か」の判定をループが外れる前に行いたいのみなので、使用するカウンタは1つのみ。
保存する文字列と合わせて計２つの入力文字のコピーが必要になる。  
目指すメモリの状態は以下
```
 0:97(a)
>1:97(a)
```
とりあえず値をコピーする
```
[>+>+<<-]
```
現在の番地の値の回数一つ右とその一つ右にインクリメントするため、右二つに現在番地の値がコピーされる。
また、現在の番地はデクリメントしてしまうため、0になってしまう。  
実行後のメモリ状態は以下
```
>0:0
 1:97(a)
 2:97(a)
```
このままだと保存する値の箇所である0番地に値がないので、不必要な2番地の値を0番地に送る。  
まずポインタを2番地に移動して
```
>>
```
```
 0:0
 1:97(a)
>2:97(a)
```
それから現在地の値を二つ前の番地に送る以下を実行
```
[<<+>>-]
```
カウンタとなった2番地の値は壊滅して0に戻るので、実行後のメモリは以下のようになる。
```
 0:97(a)
 1:97(a)
>2:0
```
これで入力文字列を判定するメモリ状態になった。  

壊滅させて良い1番地の値を使用して改行文字かの判定を行なう。
判定自体は、文字入力のループで行うため、必要とされる事柄は、
1. [LF]が入力された場合は現在番地がfalse(0)になる。
1. [LF]以外が入力された場合は、ポインタが1番地を指し示している状態で1番地の値がtrue(1以上)である。

この2点で判定する。
まず、判定文字になる1番地に移動するため、以下
```
<
```
その後、条件を満たすために、1番地の値を-10する
```
----------
```
これで[LF]の場合は0それ以外の場合は1以上になる。(ASCIIで10以下が入力された場合も同様の動作になってしまうが気にしない)  
例の場合のメモリ状態は以下
```
 0:97(a)
>1:87
 2:0
```
これで、以下ループを閉じることで、[LF]の場合はループから抜け出し次の処理を行い、それ以外の場合はループして再度入力を受け付けるようになる。
```
]
```
これで、[LF]が入力されるまで繰り返しで入力を受け付けるようになる。  
例の入力を受け終わった後は以下のメモリ状態
```
 0:97(a)
 1:98(b)
 2:99(c)
 3:100(d)
 4:101(e)
 5:102(f)
 6:10([LF])
>7:0
 8:0
```
出力したいのは5番地からなので、ポインタを動かす必要がある。
### 出力部
0番地まで繰り返しで値を出力したい。
-1番地の値は0なので、繰り返しで5番地から0番地まで出力した後-1番地の判定で止めればよさそうだ。  
現在7番地にいるので、まず6番地に移動する。
```
<
```
メモリ状態は以下
```
 0:97(a)
 1:98(b)
 2:99(c)
 3:100(d)
 4:101(e)
 5:102(f)
 6:10([LF])
>7:0
 8:0
```
ここから-1番地まで出力する。
よって、以下のようなコードになる。
```
[<.]
```
